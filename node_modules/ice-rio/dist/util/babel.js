"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateArrayType = exports.generateFinalParams = exports.parse = void 0;
const fs_1 = __importDefault(require("fs"));
const babel_traverse_1 = __importDefault(require("babel-traverse"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
function parse(fileName) {
    const parser = require('@babel/parser');
    let source = '';
    for (let i of ['', '.ts', '.d.ts']) {
        try {
            source = fs_1.default.readFileSync(fileName + i, 'utf8');
            break;
        }
        catch (_a) { }
    }
    const ast = parser.parse(source, {
        plugins: [
            ['@babel/plugin-proposal-decorators', { legacy: true }],
            ['@babel/plugin-proposal-class-properties', { loose: true }],
            'typescript',
            'classProperties',
            'decorators-legacy'
        ],
        sourceType: 'module'
    });
    return ast;
}
exports.parse = parse;
function generateFinalParams(ast, controller, dir, enableApiDoc = false) {
    const methods = constants_1.controllerMethodsMap.get(controller) || new Map();
    const importedMap = constants_1.importedControllerMap.get(controller) || {};
    const moduleTypeParamsMap = {};
    const moduleTypeParamsObjectMap = {};
    let className = '';
    function searchDir(pathNode, dir) {
        var _a;
        for (let i of pathNode.node.specifiers) {
            let p = '';
            let v = pathNode.node.source.value;
            if (!v.startsWith('.') && !v.startsWith('/')) {
                let [f, s] = v.split('/');
                let d = `node_modules/${f}`;
                let packageJson = JSON.parse(String(fs_1.default.readFileSync(path_1.default.join(process.cwd(), `${d}/package.json`))));
                let typeDir = packageJson['types'] || packageJson['typings'];
                p = path_1.default.join(`node_modules/${v}/`, `${typeDir}`, `${s ? '/' + s : ''}`);
            }
            else {
                p = path_1.default.join(dir, v);
            }
            try {
                if (fs_1.default.lstatSync(p).isDirectory()) {
                    p = path_1.default.join(p, '/index');
                }
            }
            catch (_b) { }
            ((_a = i === null || i === void 0 ? void 0 : i.imported) === null || _a === void 0 ? void 0 : _a.name) && (importedMap[i.imported.name] = p);
        }
    }
    (0, babel_traverse_1.default)(ast, {
        ClassMethod(n) {
            var _a;
            let methodNode = n.node;
            const leadingComments = methodNode.leadingComments;
            let methodName = methodNode.key.name;
            let returnNodes = methodNode.returnType;
            function resolveReference({ node, parent, key, nodeType }) {
                var _a;
                const referenceName = ((_a = node === null || node === void 0 ? void 0 : node.typeName) === null || _a === void 0 ? void 0 : _a.name) || node.expression.name;
                const fileName = importedMap[referenceName];
                const dir = fileName.slice(0, fileName.lastIndexOf('/'));
                const referenceAst = parse(fileName);
                (0, babel_traverse_1.default)(referenceAst, {
                    ExportNamedDeclaration(path) {
                        var _a, _b, _c, _d;
                        const moduleName = (_a = path.node.declaration) === null || _a === void 0 ? void 0 : _a.id.name;
                        if (!moduleName)
                            return;
                        const declaration = path.node.declaration;
                        const { typeParameters, extends: extend } = declaration;
                        const type = declaration.type;
                        const nodeMap = {
                            TSTypeAliasDeclaration: declaration === null || declaration === void 0 ? void 0 : declaration.typeAnnotation,
                            TSInterfaceDeclaration: declaration === null || declaration === void 0 ? void 0 : declaration.body,
                            TSEnumDeclaration: declaration === null || declaration === void 0 ? void 0 : declaration.members
                        };
                        const node = nodeMap[type];
                        if (!node) {
                            console.error(`External references only support interfaces、types and enum in the params or return of ${className}.${methodName},the type is ${type}`);
                            return;
                        }
                        if (type === 'TSEnumDeclaration') {
                            parent[key] = typeof (((_c = (_b = node === null || node === void 0 ? void 0 : node[0]) === null || _b === void 0 ? void 0 : _b.initializer) === null || _c === void 0 ? void 0 : _c.value) || 0);
                            return;
                        }
                        nodeType = node.type;
                        if (referenceName === moduleName) {
                            const ret = {};
                            if (typeParameters) {
                                (_d = typeParameters.params) === null || _d === void 0 ? void 0 : _d.forEach((i, index) => {
                                    ret[i.name] = moduleTypeParamsMap[moduleName][index];
                                });
                            }
                            moduleTypeParamsObjectMap[moduleName] = ret;
                            generateParam({
                                node,
                                parent,
                                key,
                                nodeType,
                                parentModuleName: typeParameters ? moduleName : undefined
                            });
                            if (extend) {
                                for (let node of extend) {
                                    let r = {};
                                    resolveReference({ node, parent: r, key: 'value', nodeType });
                                    Object.keys(r.value).forEach((i) => {
                                        parent[key][i] = r.value[i];
                                    });
                                }
                            }
                        }
                    },
                    ImportDeclaration(pathNode) {
                        searchDir(pathNode, dir);
                    }
                });
            }
            function generateParam({ node, parent, key, nodeType, parentModuleName, optional, paramsDecorate }) {
                var _a;
                const TsTypeAnnotationTypeMap = {
                    TSTypeLiteral: generateParam,
                    TSArrayType: generateParam,
                    TSTypeReference: resolveReference,
                    TsMethodParamVale: generateParam,
                    TSInterfaceBody: generateParam,
                    TSBooleanKeyword: 'boolean',
                    TSStringKeyword: 'string',
                    TSNumberKeyword: 'number'
                };
                if (nodeType === 'TSAnyKeyword')
                    return;
                const t = TsTypeAnnotationTypeMap[nodeType];
                if (!t) {
                    throw new Error(`the type ${nodeType} in the params or return of ${className}.${methodName} does not support`);
                }
                if (typeof t === 'string') {
                    parent[key] = optional ? t + ' | ' + 'undefined' : t;
                }
                else if (typeof t === 'function') {
                    if (optional) {
                        throw new Error(`the object in the params or return of ${className}.${methodName} does not support optional`);
                    }
                    const nodeParamsKeyMap = {
                        TsMethodParamVale: 'params',
                        TSTypeLiteral: 'members',
                        TSInterfaceBody: 'body'
                    };
                    const { typeParameters } = node;
                    const typeParametersParams = typeParameters === null || typeParameters === void 0 ? void 0 : typeParameters.params;
                    if (node.type === 'TSArrayType') {
                        parent = parent[key] = new CreateArrayType('');
                        t({
                            node: node.elementType,
                            parent,
                            key: '__value__',
                            nodeType: node.elementType.type
                        });
                    }
                    else {
                        const nodeParams = node[nodeParamsKeyMap[nodeType]];
                        if (nodeType === 'TSTypeReference') {
                            const moduleName = node.typeName.name;
                            if (parentModuleName &&
                                moduleTypeParamsObjectMap[parentModuleName][moduleName]) {
                                const node = moduleTypeParamsObjectMap[parentModuleName][moduleName];
                                const nodeType = node.type;
                                generateParam({ node, nodeType, key, parent });
                            }
                            else {
                                typeParametersParams &&
                                    (moduleTypeParamsMap[moduleName] = typeParametersParams);
                                t({ node, nodeType, key, parent });
                            }
                        }
                        else {
                            parent = parent[key] = {};
                            for (let i = 0; i < nodeParams.length; i++) {
                                if (paramsDecorate && !paramsDecorate[i])
                                    continue;
                                let nodeParam = nodeParams[i];
                                node = (_a = nodeParam === null || nodeParam === void 0 ? void 0 : nodeParam.typeAnnotation) === null || _a === void 0 ? void 0 : _a.typeAnnotation;
                                optional = nodeParam.optional;
                                key =
                                    nodeParam.type === 'TSPropertySignature'
                                        ? nodeParam.key.name
                                        : nodeParam.name;
                                nodeType = node.type;
                                t({ node, nodeType, key, parent, parentModuleName, optional });
                            }
                        }
                    }
                }
            }
            function generateReturnType(node, result = {}) {
                if (node.typeName.name === 'Promise') {
                    const PromiseNode = node.typeParameters.params[0];
                    generateParam({
                        node: PromiseNode,
                        parent: result,
                        key: 'value',
                        nodeType: PromiseNode.type
                    });
                }
                else {
                    throw new Error(`the return of ${className}.${methodName} must be Promise`);
                }
                return result.value;
            }
            let u = methods.get(methodName);
            let params = ((_a = methods === null || methods === void 0 ? void 0 : methods.get(methodName)) === null || _a === void 0 ? void 0 : _a.params) || [];
            if (!params.length)
                return;
            enableApiDoc &&
                (!(returnNodes === null || returnNodes === void 0 ? void 0 : returnNodes.typeAnnotation)
                    ? console.warn(`${className}.${methodName} : need add return Type`)
                    : (u.returnType = generateReturnType(returnNodes.typeAnnotation, {})));
            let r = {};
            generateParam({
                node: methodNode,
                parent: r,
                key: 'value',
                nodeType: 'TsMethodParamVale',
                optional: false,
                paramsDecorate: params.map((i) => i.decorateType)
            });
            u.paramsType = r.value;
            leadingComments === null || leadingComments === void 0 ? void 0 : leadingComments.forEach((i) => {
                if (i.value.includes('@description:')) {
                    u.apiDoc.description = i.value
                        .split('@description:')[1]
                        .split(`\n`)[0]
                        .trim();
                }
            });
        },
        ImportDeclaration(pathNode) {
            searchDir(pathNode, dir);
        },
        Class(n) {
            className = n.node.id.name;
        }
    });
}
exports.generateFinalParams = generateFinalParams;
class CreateArrayType {
    constructor(__value__) {
        this.__value__ = __value__;
    }
}
exports.CreateArrayType = CreateArrayType;
