import fs from 'fs';
import traverse from 'babel-traverse';
import path from 'path';
import { importedControllerMap, controllerMethodsMap } from './constants';
export function parse(fileName: string) {
  const parser = require('@babel/parser');
  let source = '';
  for (let i of ['', '.ts', '.d.ts']) {
    try {
      source = fs.readFileSync(fileName + i, 'utf8');
      break;
    } catch {}
  }

  const ast = parser.parse(source, {
    plugins: [
      ['@babel/plugin-proposal-decorators', { legacy: true }],
      ['@babel/plugin-proposal-class-properties', { loose: true }],
      'typescript',
      'classProperties',
      'decorators-legacy'
    ],
    sourceType: 'module'
  });
  return ast;
}

export function generateFinalParams(
  ast: any,
  controller: Object,
  dir: string,
  enableApiDoc = false
) {
  const methods = controllerMethodsMap.get(controller) || new Map();
  const importedMap = importedControllerMap.get(controller) || {};
  const moduleTypeParamsMap: Record<string, any> = {};
  const moduleTypeParamsObjectMap: Record<string, any> = {};
  let className = '';
  function searchDir(pathNode: any, dir: string) {
    for (let i of pathNode.node.specifiers) {
      let p = '';
      let v = pathNode.node.source.value;
      if (!v.startsWith('.') && !v.startsWith('/')) {
        let [f, s] = v.split('/');
        let d = `node_modules/${f}`;
        let packageJson = JSON.parse(
          String(fs.readFileSync(path.join(process.cwd(), `${d}/package.json`)))
        );
        let typeDir = packageJson['types'] || packageJson['typings'];
        p = path.join(
          `node_modules/${v}/`,
          `${typeDir}`,
          `${s ? '/' + s : ''}`
        );
      } else {
        p = path.join(dir, v);
      }
      try {
        if (fs.lstatSync(p).isDirectory()) {
          p = path.join(p, '/index');
        }
      } catch {}
      // 暂不考虑使用绝对路径的引用以及嵌套引用以及循环引用等情况
      i?.imported?.name && (importedMap[i.imported.name] = p);
    }
  }
  traverse(ast, {
    ClassMethod(n: any) {
      let methodNode = n.node;
      const leadingComments = methodNode.leadingComments;
      let methodName = methodNode.key.name;
      let returnNodes = methodNode.returnType;
      function resolveReference({
        node,
        parent,
        key,
        nodeType
      }: {
        node: any;
        parent: Record<string, any>;
        key: string;
        nodeType: string;
      }) {
        const referenceName = node?.typeName?.name || node.expression.name;
        const fileName = importedMap[referenceName];
        const dir = fileName.slice(0, fileName.lastIndexOf('/'));
        const referenceAst = parse(fileName);
        traverse(referenceAst, {
          ExportNamedDeclaration(path: any) {
            const moduleName = path.node.declaration?.id.name;
            if (!moduleName) return;
            const declaration = path.node.declaration;
            const { typeParameters, extends: extend } = declaration;
            const type = declaration.type;
            const nodeMap = {
              TSTypeAliasDeclaration: declaration?.typeAnnotation,
              TSInterfaceDeclaration: declaration?.body,
              TSEnumDeclaration: declaration?.members
            };
            //@ts-ignore
            const node = nodeMap[type];
            if (!node) {
              console.error(
                `External references only support interfaces、types and enum in the params or return of ${className}.${methodName},the type is ${type}`
              );
              return;
            }
            if (type === 'TSEnumDeclaration') {
              parent[key] = typeof (node?.[0]?.initializer?.value || 0);
              return;
            }
            nodeType = node.type;
            if (referenceName === moduleName) {
              const ret = {};
              if (typeParameters) {
                typeParameters.params?.forEach((i: any, index: number) => {
                  //@ts-ignore
                  ret[i.name] = moduleTypeParamsMap[moduleName][index];
                });
              }
              moduleTypeParamsObjectMap[moduleName] = ret;
              generateParam({
                node,
                parent,
                key,
                nodeType,
                parentModuleName: typeParameters ? moduleName : undefined
              });
              if (extend) {
                for (let node of extend) {
                  let r: Record<string, any> = {};
                  resolveReference({ node, parent: r, key: 'value', nodeType });
                  Object.keys(r.value).forEach((i) => {
                    parent[key][i] = r.value[i];
                  });
                }
              }
            }
          },
          ImportDeclaration(pathNode: any) {
            searchDir(pathNode, dir);
          }
        });
      }
      function generateParam({
        node,
        parent,
        key,
        nodeType,
        parentModuleName,
        optional,
        paramsDecorate
      }: {
        node: any;
        parent: Record<string, any>;
        key: string;
        nodeType: string;
        parentModuleName?: string;
        optional?: boolean;
        paramsDecorate?: string[];
      }) {
        const TsTypeAnnotationTypeMap = {
          // 只考虑 string、bool、number、object、和外部引用的情况
          // 对象类型,递归即可
          TSTypeLiteral: generateParam,

          TSArrayType: generateParam,
          // TSLiteralType:generateParam,
          // 引用文件
          TSTypeReference: resolveReference,
          TsMethodParamVale: generateParam,
          TSInterfaceBody: generateParam,
          TSBooleanKeyword: 'boolean',
          TSStringKeyword: 'string',
          TSNumberKeyword: 'number'
        };
        if (nodeType === 'TSAnyKeyword') return;
        //@ts-ignore
        const t = TsTypeAnnotationTypeMap[nodeType];
        if (!t) {
          throw new Error(
            `the type ${nodeType} in the params or return of ${className}.${methodName} does not support`
          );
        }
        if (typeof t === 'string') {
          parent[key] = optional ? t + ' | ' + 'undefined' : t;
        } else if (typeof t === 'function') {
          if (optional) {
            throw new Error(
              `the object in the params or return of ${className}.${methodName} does not support optional`
            );
          }
          const nodeParamsKeyMap = {
            TsMethodParamVale: 'params',
            TSTypeLiteral: 'members',
            TSInterfaceBody: 'body'
          };
          const { typeParameters } = node;
          const typeParametersParams = typeParameters?.params;
          if (node.type === 'TSArrayType') {
            parent = parent[key] = new CreateArrayType('');
            t({
              node: node.elementType,
              parent,
              key: '__value__',
              nodeType: node.elementType.type
            });
          } else {
            //@ts-ignore
            const nodeParams = node[nodeParamsKeyMap[nodeType]];
            if (nodeType === 'TSTypeReference') {
              const moduleName = node.typeName.name;
              if (
                parentModuleName &&
                moduleTypeParamsObjectMap[parentModuleName][moduleName]
              ) {
                const node =
                  moduleTypeParamsObjectMap[parentModuleName][moduleName];
                const nodeType = node.type;
                generateParam({ node, nodeType, key, parent });
              } else {
                typeParametersParams &&
                  //@ts-ignore
                  (moduleTypeParamsMap[moduleName] = typeParametersParams);
                t({ node, nodeType, key, parent });
              }
            } else {
              parent = parent[key] = {};
              for (let i = 0; i < nodeParams.length; i++) {
                // 没有装饰的参数不需要处理
                if (paramsDecorate && !paramsDecorate[i]) continue;
                let nodeParam = nodeParams[i];
                node = nodeParam?.typeAnnotation?.typeAnnotation;
                optional = nodeParam.optional;
                key =
                  nodeParam.type === 'TSPropertySignature'
                    ? nodeParam.key.name
                    : nodeParam.name;
                nodeType = node.type;
                t({ node, nodeType, key, parent, parentModuleName, optional });
              }
            }
          }
        }
      }
      function generateReturnType(node: any, result = {}) {
        if (node.typeName.name === 'Promise') {
          const PromiseNode = node.typeParameters.params[0];
          generateParam({
            node: PromiseNode,
            parent: result,
            key: 'value',
            nodeType: PromiseNode.type
          });
        } else {
          throw new Error(
            `the return of ${className}.${methodName} must be Promise`
          );
        }
        //@ts-ignore
        return result.value;
      }
      let u = methods.get(methodName);
      let params = methods?.get(methodName)?.params || [];
      if (!params.length) return;
      enableApiDoc &&
        (!returnNodes?.typeAnnotation
          ? console.warn(`${className}.${methodName} : need add return Type`)
          : (u.returnType = generateReturnType(
              returnNodes.typeAnnotation,
              {}
            )));

      let r = {};
      generateParam({
        node: methodNode,
        parent: r,
        key: 'value',
        nodeType: 'TsMethodParamVale',
        optional: false,
        paramsDecorate: params.map((i: any) => i.decorateType)
      });

      //@ts-ignore
      u.paramsType = r.value;
      leadingComments?.forEach((i: any) => {
        if (i.value.includes('@description:')) {
          //@ts-ignore
          u.apiDoc.description = i.value
            .split('@description:')[1]
            .split(`\n`)[0]
            .trim();
        }
      });
    },
    ImportDeclaration(pathNode: any) {
      searchDir(pathNode, dir);
    },
    Class(n) {
      className = n.node.id.name;
    }
  });
}

export class CreateArrayType {
  constructor(public __value__: any) {}
}
